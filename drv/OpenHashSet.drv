/*		 
 * Copyright (C) 2002-2013 Sebastiano Vigna 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 */


package PACKAGE;

import it.unimi.dsi.fastutil.Hash;
import it.unimi.dsi.fastutil.HashCommon;
import it.unimi.dsi.fastutil.booleans.BooleanArrays;
import static it.unimi.dsi.fastutil.HashCommon.arraySize;
import static it.unimi.dsi.fastutil.HashCommon.maxFill;

import java.util.Collection;
#if #keys(primitive)
import java.util.Iterator;
#endif
import java.util.NoSuchElementException;

#ifdef Linked

#if #keys(reference)
import java.util.Comparator;
#endif

/**  A type-specific linked hash set with with a fast, small-footprint implementation.
 *
 * <P>Instances of this class use a hash table to represent a set. The table is
 * enlarged as needed by doubling its size when new entries are created, but it is <em>never</em> made
 * smaller (even on a {@link #clear()}). A family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * <P>Iterators generated by this set will enumerate elements in the same order in which they
 * have been added to the set (addition of elements already present 
 * in the set does not change the iteration order). Note that this order has nothing in common with the natural
 * order of the keys. The order is kept by means of a doubly linked list, represented
 * <i>via</i> an array of longs parallel to the table.
 *
 * <P>This class implements the interface of a sorted set, so to allow easy
 * access of the iteration order: for instance, you can get the first element
 * in iteration order with {@link #first()} without having to create an
 * iterator; however, this class partially violates the {@link java.util.SortedSet}
 * contract because all subset methods throw an exception and {@link
 * #comparator()} returns always <code>null</code>.
 *
 * <p>Additional methods, such as <code>addAndMoveToFirst()</code>, make it easy
 * to use instances of this class as a cache (e.g., with LRU policy).
 *
 * <P>The iterators provided by this class are type-specific {@linkplain
 * java.util.ListIterator list iterators}, and can be started at any
 * element <em>which is in the set</em> (if the provided element 
 * is not in the set, a {@link NoSuchElementException} exception will be thrown).
 * If, however, the provided element is not the first or last element in the
 * set, the first access to the list index will require linear time, as in the worst case
 * the entire set must be scanned in iteration order to retrieve the positional
 * index of the starting element. If you use just the methods of a type-specific {@link it.unimi.dsi.fastutil.BidirectionalIterator},
 * however, all operations will be performed in constant time.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_SET KEY_GENERIC extends ABSTRACT_SORTED_SET KEY_GENERIC implements java.io.Serializable, Cloneable, Hash {

#else

#ifdef Custom

/** A type-specific hash set with a fast, small-footprint implementation whose {@linkplain it.unimi.dsi.fastutil.Hash.Strategy hashing strategy}
 * is specified at creation time.
 *
 * <P>Instances of this class use a hash table to represent a set. The table is
 * enlarged as needed by doubling its size when new entries are created, but it is <em>never</em> made
 * smaller (even on a {@link #clear()}). A family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * <p><strong>Warning:</strong> The implementation of this class has significantly
 * changed in <code>fastutil</code> 6.1.0. Please read the
 * comments about this issue in the section &ldquo;Faster Hash Tables&rdquo; of the <a href="../../../../../overview-summary.html">overview</a>.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_SET KEY_GENERIC extends ABSTRACT_SET KEY_GENERIC implements java.io.Serializable, Cloneable, Hash {

#else

/**  A type-specific hash set with with a fast, small-footprint implementation.
 *
 * <P>Instances of this class use a hash table to represent a set. The table is
 * enlarged as needed by doubling its size when new entries are created, but it is <em>never</em> made
 * smaller (even on a {@link #clear()}). A family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * <p><strong>Warning:</strong> The implementation of this class has significantly
 * changed in <code>fastutil</code> 6.1.0. Please read the
 * comments about this issue in the section &ldquo;Faster Hash Tables&rdquo; of the <a href="../../../../../overview-summary.html">overview</a>.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_SET KEY_GENERIC extends ABSTRACT_SET KEY_GENERIC implements java.io.Serializable, Cloneable, Hash {

#endif

#endif

    private static final long serialVersionUID = 0L;
	private static final boolean ASSERTS = ASSERTS_VALUE;

	/** The array of keys. */
	protected transient KEY_GENERIC_TYPE key[];
	 
	/** The array telling whether a position is used. */
	protected transient boolean used[];

	/** The acceptable load factor. */
	protected final float f;
	 
	/** The current table size. */
	protected transient int n;

	/** Threshold after which we rehash. It must be the table size times {@link #f}. */
	protected transient int maxFill;

	/** The mask for wrapping a position counter. */
	protected transient int mask;

	/** Number of entries in the set. */
	protected int size;

#ifdef Linked
	/** The index of the first entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1. */
	protected transient int first = -1;
	/** The index of the last entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1. */
	protected transient int last = -1;
	/** For each entry, the next and the previous entry in iteration order,
     * stored as <code>((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)</code>.
     * The first entry contains predecessor -1, and the last entry 
     * contains successor -1. */
	protected transient long link[];
#endif

#ifdef Custom
	/** The hash strategy of this custom set. */
	protected STRATEGY KEY_GENERIC strategy;
#endif

#ifdef Custom
	/** Creates a new hash set.
	 *
	 * <p>The actual table size will be the least power of two greater than <code>expected</code>/<code>f</code>.
	 *
	 * @param expected the expected number of elements in the hash set. 
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	@SuppressWarnings("unchecked")
	public OPEN_HASH_SET( final int expected, final float f, final STRATEGY KEY_GENERIC strategy ) {
		this.strategy = strategy;
#else
	/** Creates a new hash set.
	 *
	 * <p>The actual table size will be the least power of two greater than <code>expected</code>/<code>f</code>.
	 *
	 * @param expected the expected number of elements in the hash set. 
	 * @param f the load factor.
	 */
	@SuppressWarnings("unchecked")
	public OPEN_HASH_SET( final int expected, final float f ) {
#endif
		if ( f <= 0 || f > 1 ) throw new IllegalArgumentException( "Load factor must be greater than 0 and smaller than or equal to 1" );
		if ( expected < 0 ) throw new IllegalArgumentException( "The expected number of elements must be nonnegative" );

		this.f = f;

		n = arraySize( expected, f );
		mask = n - 1;
		maxFill = maxFill( n, f );
		key = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[ n ];
		used = new boolean[ n ];
#ifdef Linked
		link = new long[ n ];
#endif
	}
	 
	 
#ifdef Custom
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 *
	 * @param expected the expected number of elements in the hash set. 
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final int expected, final STRATEGY KEY_GENERIC strategy ) {
		this( expected, DEFAULT_LOAD_FACTOR, strategy );
	}

#else
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 *
	 * @param expected the expected number of elements in the hash set. 
	 */
	 
	public OPEN_HASH_SET( final int expected ) {
		this( expected, DEFAULT_LOAD_FACTOR );
	}

#endif


#ifdef Custom
	/** Creates a new hash set with initial expected {@link Hash#DEFAULT_INITIAL_SIZE} elements
	 * and {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final STRATEGY KEY_GENERIC strategy ) {
	this( DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, strategy );
	}
#else
	/** Creates a new hash set with initial expected {@link Hash#DEFAULT_INITIAL_SIZE} elements
	 * and {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 */
	 
	public OPEN_HASH_SET() {
		this( DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR );
	} 
#endif


#ifdef Custom
	/** Creates a new hash set copying a given collection.
	 *
	 * @param c a {@link Collection} to be copied into the new hash set. 
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final Collection<? extends KEY_GENERIC_CLASS> c, final float f, final STRATEGY KEY_GENERIC strategy ) {
	this( c.size(), f, strategy );
		addAll( c );
	}
#else
	/** Creates a new hash set copying a given collection.
	 *
	 * @param c a {@link Collection} to be copied into the new hash set. 
	 * @param f the load factor.
	 */
	 
	public OPEN_HASH_SET( final Collection<? extends KEY_GENERIC_CLASS> c, final float f ) {
		this( c.size(), f );
		addAll( c );
	}
#endif



#ifdef Custom
	/** Creates a new hash set  with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor 
	 * copying a given collection.
	 *
	 * @param c a {@link Collection} to be copied into the new hash set. 
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final Collection<? extends KEY_GENERIC_CLASS> c, final STRATEGY KEY_GENERIC strategy ) {
		this( c, DEFAULT_LOAD_FACTOR, strategy );
	}

#else
	/** Creates a new hash set  with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor 
	 * copying a given collection.
	 *
	 * @param c a {@link Collection} to be copied into the new hash set. 
	 */
	 
	public OPEN_HASH_SET( final Collection<? extends KEY_GENERIC_CLASS> c ) {
		this( c, DEFAULT_LOAD_FACTOR );
	}
#endif


#ifdef Custom
	/** Creates a new hash set copying a given type-specific collection.
	 *
	 * @param c a type-specific collection to be copied into the new hash set. 
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final COLLECTION KEY_EXTENDS_GENERIC c, final float f, STRATEGY KEY_GENERIC strategy ) {
	this( c.size(), f, strategy );
		addAll( c );
	}
#else
	/** Creates a new hash set copying a given type-specific collection.
	 *
	 * @param c a type-specific collection to be copied into the new hash set. 
	 * @param f the load factor.
	 */
	 
	public OPEN_HASH_SET( final COLLECTION KEY_EXTENDS_GENERIC c, final float f ) {
		this( c.size(), f );
		addAll( c );
	}
#endif


#ifdef Custom
	/** Creates a new hash set  with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor 
	 * copying a given type-specific collection.
	 *
	 * @param c a type-specific collection to be copied into the new hash set. 
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final COLLECTION KEY_EXTENDS_GENERIC c, final STRATEGY KEY_GENERIC strategy ) {
		this( c, DEFAULT_LOAD_FACTOR, strategy );
	}
#else
	/** Creates a new hash set  with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor 
	 * copying a given type-specific collection.
	 *
	 * @param c a type-specific collection to be copied into the new hash set. 
	 */
	 
	public OPEN_HASH_SET( final COLLECTION KEY_EXTENDS_GENERIC c ) {
		this( c, DEFAULT_LOAD_FACTOR );
	}
#endif


#ifdef Custom
	/** Creates a new hash set using elements provided by a type-specific iterator.
	 *
	 * @param i a type-specific iterator whose elements will fill the set.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final KEY_ITERATOR KEY_GENERIC i, final float f, final STRATEGY KEY_GENERIC strategy ) {
		this( DEFAULT_INITIAL_SIZE, f, strategy );
		while( i.hasNext() ) add( i.NEXT_KEY() );
	}
#else
	/** Creates a new hash set using elements provided by a type-specific iterator.
	 *
	 * @param i a type-specific iterator whose elements will fill the set.
	 * @param f the load factor.
	 */
	 
	public OPEN_HASH_SET( final KEY_ITERATOR KEY_GENERIC i, final float f ) {
		this( DEFAULT_INITIAL_SIZE, f );
		while( i.hasNext() ) add( i.NEXT_KEY() );
	}
#endif

#ifdef Custom
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using elements provided by a type-specific iterator.
	 *
	 * @param i a type-specific iterator whose elements will fill the set.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final KEY_ITERATOR KEY_GENERIC i, final STRATEGY KEY_GENERIC strategy ) {
		this( i, DEFAULT_LOAD_FACTOR, strategy );
	}
#else
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using elements provided by a type-specific iterator.
	 *
	 * @param i a type-specific iterator whose elements will fill the set.
	 */
	 
	public OPEN_HASH_SET( final KEY_ITERATOR KEY_GENERIC i ) {
		this( i, DEFAULT_LOAD_FACTOR );
	}
#endif



#if #keys(primitive)

#ifdef Custom
	/** Creates a new hash set using elements provided by an iterator.
	 *
	 * @param i an iterator whose elements will fill the set.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final Iterator<?> i, final float f, final STRATEGY KEY_GENERIC strategy ) {
		this( ITERATORS.AS_KEY_ITERATOR( i ), f, strategy );
	}
#else
	/** Creates a new hash set using elements provided by an iterator.
	 *
	 * @param i an iterator whose elements will fill the set.
	 * @param f the load factor.
	 */
	 
	public OPEN_HASH_SET( final Iterator<?> i, final float f ) {
		this( ITERATORS.AS_KEY_ITERATOR( i ), f );
	}
#endif

#ifdef Custom
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using elements provided by an iterator.
	 *
	 * @param i an iterator whose elements will fill the set.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final Iterator<?> i, final STRATEGY KEY_GENERIC strategy ) {
		this( ITERATORS.AS_KEY_ITERATOR( i ), strategy );
	}
#else
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using elements provided by an iterator.
	 *
	 * @param i an iterator whose elements will fill the set.
	 */
	 
	public OPEN_HASH_SET( final Iterator<?> i ) {
		this( ITERATORS.AS_KEY_ITERATOR( i ) );
	}
#endif

#endif



#ifdef Custom
	/** Creates a new hash set and fills it with the elements of a given array.
	 *
	 * @param a an array whose elements will be used to fill the set.
	 * @param offset the first element to use.
	 * @param length the number of elements to use.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final KEY_GENERIC_TYPE[] a, final int offset, final int length, final float f, final STRATEGY KEY_GENERIC strategy ) {
	this( length < 0 ? 0 : length, f, strategy );
		ARRAYS.ensureOffsetLength( a, offset, length );
		for( int i = 0; i < length; i++ ) add( a[ offset + i ] );
	}
#else
	/** Creates a new hash set and fills it with the elements of a given array.
	 *
	 * @param a an array whose elements will be used to fill the set.
	 * @param offset the first element to use.
	 * @param length the number of elements to use.
	 * @param f the load factor.
	 */
	 
	public OPEN_HASH_SET( final KEY_GENERIC_TYPE[] a, final int offset, final int length, final float f ) {
		this( length < 0 ? 0 : length, f );
		ARRAYS.ensureOffsetLength( a, offset, length );
		for( int i = 0; i < length; i++ ) add( a[ offset + i ] );
	}
#endif

#ifdef Custom
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor and fills it with the elements of a given array.
	 *
	 * @param a an array whose elements will be used to fill the set.
	 * @param offset the first element to use.
	 * @param length the number of elements to use.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final KEY_GENERIC_TYPE[] a, final int offset, final int length, final STRATEGY KEY_GENERIC strategy ) {
		this( a, offset, length, DEFAULT_LOAD_FACTOR, strategy );
	}
#else
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor and fills it with the elements of a given array.
	 *
	 * @param a an array whose elements will be used to fill the set.
	 * @param offset the first element to use.
	 * @param length the number of elements to use.
	 */
	 
	public OPEN_HASH_SET( final KEY_GENERIC_TYPE[] a, final int offset, final int length ) {
		this( a, offset, length, DEFAULT_LOAD_FACTOR );
	}
#endif

#ifdef Custom
	/** Creates a new hash set copying the elements of an array.
	 *
	 * @param a an array to be copied into the new hash set. 
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final KEY_GENERIC_TYPE[] a, final float f, final STRATEGY KEY_GENERIC strategy ) {
		this( a, 0, a.length, f, strategy );
	}
#else
	/** Creates a new hash set copying the elements of an array.
	 *
	 * @param a an array to be copied into the new hash set. 
	 * @param f the load factor.
	 */
	 
	public OPEN_HASH_SET( final KEY_GENERIC_TYPE[] a, final float f ) {
		this( a, 0, a.length, f );
	}
#endif

#ifdef Custom
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor 
	 * copying the elements of an array.
	 *
	 * @param a an array to be copied into the new hash set. 
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_SET( final KEY_GENERIC_TYPE[] a, final STRATEGY KEY_GENERIC strategy ) {
		this( a, DEFAULT_LOAD_FACTOR, strategy );
	}
#else
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor 
	 * copying the elements of an array.
	 *
	 * @param a an array to be copied into the new hash set. 
	 */
	 
	public OPEN_HASH_SET( final KEY_GENERIC_TYPE[] a ) {
		this( a, DEFAULT_LOAD_FACTOR );
	}
#endif


#ifdef Custom
	/** Returns the hashing strategy.
	 *
	 * @return the hashing strategy of this custom hash set.
	 */

	public STRATEGY KEY_GENERIC strategy() {
		return strategy;
	}
#endif

	/*
	 * The following methods implements some basic building blocks used by
	 * all accessors. They are (and should be maintained) identical to those used in HashMap.drv.
	 */

	public boolean add( final KEY_GENERIC_TYPE k ) {
		// The starting point.
		int pos = KEY2INTHASH( k ) & mask;

		// There's always an unused entry.
		while( used[ pos ] ) {
			if ( KEY_EQUALS( key[ pos ], k ) ) return false;
			pos = ( pos + 1 ) & mask;
		}

		used[ pos ] = true;
		key[ pos ] = k;

#ifdef Linked
		if ( size == 0 ) {
			first = last = pos;
			// Special case of SET(link[ pos ], -1, -1);
			link[ pos ] = -1L;
		}
		else {
			SET_NEXT( link[ last ], pos );
			SET_UPPER_LOWER( link[ pos ], last, -1 );
			last = pos;
		}
#endif

		if ( ++size >= maxFill ) rehash( arraySize( size + 1, f ) );
		if ( ASSERTS ) checkTable();
		return true;
	}

	/** Shifts left entries with the specified hash code, starting at the specified position,
	 * and empties the resulting free entry.
	 *
	 * @param pos a starting position.
	 * @return the position cleared by the shifting process.
	 */
	protected final int shiftKeys( int pos ) {
		// Shift entries with the same hash.
		int last, slot;

		for(;;) {
			pos = ( ( last = pos ) + 1 ) & mask;
			
			while( used[ pos ] ) {
				slot = KEY2INTHASH( key[ pos ] ) & mask;
				if ( last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos ) break;
				pos = ( pos + 1 ) & mask;
			}

			if ( ! used[ pos ] ) break;

			key[ last ] = key[ pos ];			

#ifdef Linked
			fixPointers( pos, last );
#endif
		}

		used[ last ] = false;
#if #keys(reference)
		key[ last ] = null;
#endif
		return last;
	}


	@SuppressWarnings("unchecked")
	public boolean remove( final KEY_TYPE k ) {
		// The starting point.
		int pos = KEY2INTHASH( k ) & mask;

		// There's always an unused entry.
		while( used[ pos ] ) {
			if ( KEY_EQUALS( key[ pos ], k ) ) {
				size--;
#ifdef Linked
				fixPointers( pos );
#endif
				shiftKeys( pos );
				if ( ASSERTS ) checkTable();
				return true;
			}
			pos = ( pos + 1 ) & mask;
		}
		return false;
	}
	 
	@SuppressWarnings("unchecked")
	public boolean contains( final KEY_TYPE k ) {
		// The starting point.
		int pos = KEY2INTHASH( k ) & mask;

		// There's always an unused entry.
		while( used[ pos ] ) {
			if ( KEY_EQUALS( key[ pos ], k ) ) return true;
			pos = ( pos + 1 ) & mask;
		}
		return false;
	}

#if #keyclass(Object)
	/** Returns the element of this set that is equal to the given key, or <code>null</code>.
	 * @return the element of this set that is equal to the given key, or <code>null</code>.
	 */
	@SuppressWarnings("unchecked")
	public K get( final Object k ) {
		// The starting point.
		int pos = KEY2INTHASH( k ) & mask;

		// There's always an unused entry.
		while( used[ pos ] ) {
			if ( KEY_EQUALS( key[ pos ], k ) ) return key[ pos ];
			pos = ( pos + 1 ) & mask;
		}
		return null;
	}
#endif

#ifdef Linked
	
	/** Removes the first key in iteration order.
	 * @return the first key.
	 * @throws NoSuchElementException is this set is empty.
	 */
	public KEY_GENERIC_TYPE REMOVE_FIRST_KEY() {
		if ( size == 0 ) throw new NoSuchElementException();
		--size;
		final int pos = first;
		// Abbreviated version of fixPointers(pos)
		first = GET_NEXT(link[ pos ]);
		if ( 0 <= first ) {
			// Special case of SET_PREV( link[ first ], -1 )
			link[ first ] |= (-1 & 0xFFFFFFFFL) << 32;
		}
		final KEY_GENERIC_TYPE k = key[ pos ];
		shiftKeys( pos );	
		return k;
	}

	/** Removes the the last key in iteration order.
	 * @return the last key.
	 * @throws NoSuchElementException is this set is empty.
	 */
	public KEY_GENERIC_TYPE REMOVE_LAST_KEY() {
		if ( size == 0 ) throw new NoSuchElementException();
		--size;
		final int pos = last;
		// Abbreviated version of fixPointers(pos)
		last = GET_PREV(link[ pos ]);
		if ( 0 <= last ) {
			// Special case of SET_NEXT( link[ last ], -1 )
			link[ last ] |= -1 & 0xFFFFFFFFL;
		}
		final KEY_GENERIC_TYPE k = key[ pos ];
		shiftKeys( pos );
		return k;
	}

	private void moveIndexToFirst( final int i ) {
		if ( size == 1 || first == i ) return;
		if ( last == i ) {
			last = GET_PREV(link[ i ]);
			// Special case of SET_NEXT( link[ last ], -1 );
			link[ last ] |= -1 & 0xFFFFFFFFL;
		}
		else {
			final long linki = link[ i ];
			final int prev = GET_PREV(linki);
			final int next = GET_NEXT(linki);
			COPY_NEXT(link[ prev ], linki);
			COPY_PREV(link[ next ], linki);
		}
		SET_PREV( link[ first ], i );
		SET_UPPER_LOWER( link[ i ], -1, first );
		first = i;
	}

	private void moveIndexToLast( final int i ) {
		if ( size == 1 ||  last == i ) return;
		if ( first == i ) {
			first = GET_NEXT(link[ i ]);
			// Special case of SET_PREV( link[ first ], -1 );
			link[ first ] |= (-1 & 0xFFFFFFFFL) << 32;
		}
		else {
			final long linki = link[ i ];
			final int prev = GET_PREV(linki);
			final int next = GET_NEXT(linki);
			COPY_NEXT(link[ prev ], linki);
			COPY_PREV(link[ next ], linki);
		}
		SET_NEXT( link[ last ], i );
		SET_UPPER_LOWER( link[ i ], last, -1 );
		last = i;
	}

	/** Adds a key to the set; if the key is already present, it is moved to the first position of the iteration order.
	 *
	 * @param k the key.
	 * @return true if the key was not present.
	 */
	public boolean addAndMoveToFirst( final KEY_GENERIC_TYPE k ) {
		final KEY_GENERIC_TYPE key[] = this.key;
		final boolean used[] = this.used;
		final int mask = this.mask;

		// The starting point.
		int pos = KEY2INTHASH( k ) & mask;

		// There's always an unused entry.
		while( used[ pos ] ) {
			if ( KEY_EQUALS( k, key[ pos ] ) ) {
				moveIndexToFirst( pos );
				return false;
			}
			
			pos = ( pos + 1 ) & mask;
		}
		  
		used[ pos ] = true;
		key[ pos ] = k;
		
		if ( size == 0 ) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
			link[ pos ] = -1L;
		}
		else {
			SET_PREV( link[ first ], pos );
			SET_UPPER_LOWER( link[ pos ], -1, first );
			first = pos;
		}

		if ( ++size >= maxFill ) rehash( arraySize( size, f ) );
		if ( ASSERTS ) checkTable();
		return true;
	}

	/** Adds a key to the set; if the key is already present, it is moved to the last position of the iteration order.
	 *
	 * @param k the key.
	 * @return true if the key was not present.
	 */
	public boolean addAndMoveToLast( final KEY_GENERIC_TYPE k ) {
		final KEY_GENERIC_TYPE key[] = this.key;
		final boolean used[] = this.used;
		final int mask = this.mask;

		// The starting point.
		int pos = KEY2INTHASH( k ) & mask;

		// There's always an unused entry.
		while( used[ pos ] ) {
			if ( KEY_EQUALS( k, key[ pos ] ) ) {
				moveIndexToLast( pos );
				return false;
			}
			
			pos = ( pos + 1 ) & mask;
		}
		  
		used[ pos ] = true;
		key[ pos ] = k;
		
		if ( size == 0 ) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
			link[ pos ] = -1L;
		}
		else {
			SET_NEXT( link[ last ], pos );
			SET_UPPER_LOWER( link[ pos ], last, -1 );
			last = pos;
		}

		if ( ++size >= maxFill ) rehash( arraySize( size, f ) );
		if ( ASSERTS ) checkTable();
		return true;
	}

#endif

	/* Removes all elements from this set.
	 *
	 * <P>To increase object reuse, this method does not change the table size.
	 * If you want to reduce the table size, you must use {@link #trim()}.
	 *
	 */

	public void clear() {
		if ( size == 0 ) return;
		size = 0;
		BooleanArrays.fill( used, false );

#if #keys(reference)
		ObjectArrays.fill( key, null );
#endif
#ifdef Linked
		first = last = -1;
#endif
	}


	public int size() {
		return size;
	}

	public boolean isEmpty() {
		return size == 0;
	}

	/** A no-op for backward compatibility.
	 * 
	 * @param growthFactor unused.
	 * @deprecated Since <code>fastutil</code> 6.1.0, hash tables are doubled when they are too full.
	 */
	@Deprecated
	public void growthFactor( int growthFactor ) {}


	/** Gets the growth factor (2).
	 *
	 * @return the growth factor of this set, which is fixed (2).
	 * @see #growthFactor(int)
	 * @deprecated Since <code>fastutil</code> 6.1.0, hash tables are doubled when they are too full.
	 */
	@Deprecated
	public int growthFactor() {
		return 16;
	}



#ifdef Linked

	/** Modifies the {@link #link} vector so that the given entry is removed.
	 *
	 * <P>If the given entry is the first or the last one, this method will complete
	 * in constant time; otherwise, it will have to search for the given entry.
	 *
	 * @param i the index of an entry. 
	 */
	protected void fixPointers( final int i ) {
		if ( size == 0 ) {
			first = last = -1;
			return;
		}
		if ( first == i ) {
			first = GET_NEXT(link[ i ]);
			if (0 <= first) {
				// Special case of SET_PREV( link[ first ], -1 )
				link[ first ] |= (-1 & 0xFFFFFFFFL) << 32;
			}
			return;
		}
		if ( last == i ) {
			last = GET_PREV(link[ i ]);
			if (0 <= last) {
				// Special case of SET_NEXT( link[ last ], -1 )
				link[ last ] |= -1 & 0xFFFFFFFFL;
			}
			return;
		}
		final long linki = link[ i ];
		final int prev = GET_PREV(linki);
		final int next = GET_NEXT(linki);
		COPY_NEXT(link[ prev ], linki);
		COPY_PREV(link[ next ], linki);
	}


	/** Modifies the {@link #link} vector for a shift from s to d.
	 *
	 * <P>If the given entry is the first or the last one, this method will complete
	 * in constant time; otherwise, it will have to search for the given entry.
	 *
	 * @param s the source position.
	 * @param d the destination position.
	 */
	protected void fixPointers( int s, int d ) {
		if ( size == 1 ) {
			first = last = d;
			// Special case of SET(link[ d ], -1, -1)
			link[ d ] = -1L;
			return;
		}
		if ( first == s ) {
			first = d;
			SET_PREV( link[ GET_NEXT(link[ s ]) ], d );
			link[ d ] = link[ s ];
			return;
		}
		if ( last == s ) {
			last = d;
			SET_NEXT( link[ GET_PREV(link[ s ])], d );
			link[ d ] = link[ s ];
			return;
		}
		final long links = link[ s ];
		final int prev = GET_PREV(links);
		final int next = GET_NEXT(links);
		SET_NEXT( link[ prev ], d );
		SET_PREV( link[ next ], d );
		link[ d ] = links;
	}


	/** Returns the first element of this set in iteration order.
	 *
	 * @return the first element in iteration order.
	 */
	public KEY_GENERIC_TYPE FIRST() {
		if ( size == 0 ) throw new NoSuchElementException();
		return key[ first ];
	}


	/** Returns the last element of this set in iteration order.
	 *
	 * @return the last element in iteration order.
	 */
	public KEY_GENERIC_TYPE LAST() {
		if ( size == 0 ) throw new NoSuchElementException();
		return key[ last ];
	}


	public SORTED_SET KEY_GENERIC tailSet( KEY_GENERIC_TYPE from ) { throw new UnsupportedOperationException(); }
	public SORTED_SET KEY_GENERIC headSet( KEY_GENERIC_TYPE to ) { throw new UnsupportedOperationException(); }
	public SORTED_SET KEY_GENERIC subSet( KEY_GENERIC_TYPE from, KEY_GENERIC_TYPE to ) { throw new UnsupportedOperationException(); }
	
	public KEY_COMPARATOR KEY_SUPER_GENERIC comparator() { return null; }



	/** A list iterator over a linked set.
	 *
	 * <P>This class provides a list iterator over a linked hash set. The empty constructor runs in 
	 * constant time. The one-argument constructor needs to search for the given element, but it is 
	 * optimized for the case of {@link java.util.SortedSet#last()}, in which case runs in constant time, too.
	 */
	private class SetIterator extends KEY_ABSTRACT_LIST_ITERATOR KEY_GENERIC {
		/** The entry that will be returned by the next call to {@link java.util.ListIterator#previous()} (or <code>null</code> if no previous entry exists). */
		int prev = -1;
		/** The entry that will be returned by the next call to {@link java.util.ListIterator#next()} (or <code>null</code> if no next entry exists). */
		int next = -1;
		/** The last entry that was returned (or -1 if we did not iterate or used {@link #remove()}). */
		int curr = -1;
		/** The current index (in the sense of a {@link java.util.ListIterator}). When -1, we do not know the current index.*/
		int index = -1;

		SetIterator() {
			next = first;
			index = 0;
		}

		SetIterator( KEY_GENERIC_TYPE from ) {
			if ( KEY_EQUALS( key[ last ], from ) ) {
				prev = last;
				index = size;
			}
			else {
				// The starting point.
				int pos = KEY2INTHASH( from ) & mask;

				// There's always an unused entry.
				while( used[ pos ] ) {
					if ( KEY_EQUALS( key[ pos ], from ) ) {
						// Note: no valid index known.
						next = GET_NEXT( link[ pos ] );
						prev = pos;
						return;
					}
					pos = ( pos + 1 ) & mask;
				}
				throw new NoSuchElementException( "The key " + from + " does not belong to this set." );
			}
		}
					 
		public boolean hasNext() { return next != -1; }
		public boolean hasPrevious() { return prev != -1; }
					 
		public KEY_GENERIC_TYPE NEXT_KEY() {
			if ( ! hasNext() ) throw new NoSuchElementException();

			curr = next;
			next = GET_NEXT(link[ curr ]);
			prev = curr;

			if ( index >= 0 ) index++;
			if ( ASSERTS ) assert used[ curr ] : "Position " + curr + " is not used";
			return key[ curr ];
		}

		public KEY_GENERIC_TYPE PREV_KEY() {
			if ( ! hasPrevious() ) throw new NoSuchElementException();

			curr = prev;
			prev = GET_PREV(link[ curr ]);
			next = curr;

			if ( index >= 0 ) index--;

			return key[ curr ];
		}

		private final void ensureIndexKnown() {
			if ( index >= 0 ) return;
			if ( prev == -1 ) {
				index = 0;
				return;
			}
			if ( next == -1 ) {
				index = size;
				return;
			}
			int pos = first;
			index = 1;
			while( pos != prev ) {
				pos = GET_NEXT( link[ pos ] );
				index++;
			}
		}

		public int nextIndex() {
			ensureIndexKnown();
			return index;
		}

		public int previousIndex() {
			ensureIndexKnown();
			return index - 1;
		}

		
		@SuppressWarnings("unchecked")
		public void remove() {
			ensureIndexKnown();
			if ( curr == -1 ) throw new IllegalStateException();

			if ( curr == prev ) {
				/* If the last operation was a next(), we are removing an entry that preceeds
				   the current index, and thus we must decrement it. */
				index--;
				prev = GET_PREV(link[ curr ]);
			}
			else 
				next = GET_NEXT(link[ curr ]);

			size--;
			/* Now we manually fix the pointers. Because of our knowledge of next
			   and prev, this is going to be faster than calling fixPointers(). */
			if ( prev == -1 ) first = next;
			else 
				SET_NEXT( link[ prev ], next );
			if ( next == -1 ) last = prev;
			else
				SET_PREV( link[ next ], prev );

			int last, slot, pos = curr;

			// We have to horribly duplicate the shiftKeys() code because we need to update next/prev.			
			for(;;) {
				pos = ( ( last = pos ) + 1 ) & mask;
				while( used[ pos ] ) {
					slot = KEY2INTHASH( key[ pos ] ) & mask;
					if ( last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos ) break;
					pos = ( pos + 1 ) & mask;
				}
	
				if ( ! used[ pos ] ) break;
				key[ last ] = key[ pos ];			
				if ( next == pos ) next = last;
				if ( prev == pos ) prev = last;
				fixPointers( pos, last );
			}

			used[ last ] = false;
#if #keys(reference)
			key[ last ] = null;
#endif
			curr = -1;
		}
	}


	/** Returns a type-specific list iterator on the elements in this set, starting from a given element of the set.
	 * Please see the class documentation for implementation details.
	 *
	 * @param from an element to start from.
	 * @return a type-specific list iterator starting at the given element.
	 * @throws IllegalArgumentException if <code>from</code> does not belong to the set.
	 */
	public KEY_LIST_ITERATOR KEY_GENERIC iterator( KEY_GENERIC_TYPE from ) {
		return new SetIterator( from );
	}

	public KEY_LIST_ITERATOR KEY_GENERIC iterator() {
		return new SetIterator();
	}

#else	 

	/** An iterator over a hash set. */

	private class SetIterator extends KEY_ABSTRACT_ITERATOR KEY_GENERIC {
		/** The index of the next entry to be returned, if positive or zero. If negative, the next entry to be
			returned, if any, is that of index -pos -2 from the {@link #wrapped} list. */
		int pos = OPEN_HASH_SET.this.n;
		/** The index of the last entry that has been returned (more precisely, the value of {@link #pos}). It is -1 if either
			we did not return an entry yet, or the last returned entry has been removed. */
		int last = -1;
		/** A downward counter measuring how many entries must still be returned. */
		int c = size;
		/** A lazily allocated list containing elements that have wrapped around the table because of removals; such elements
			would not be enumerated (other elements would be usually enumerated twice in their place). */
		ARRAY_LIST KEY_GENERIC wrapped;
		
		{ 
			final boolean used[] = OPEN_HASH_SET.this.used;
			if ( c != 0 ) while( ! used[ --pos ] );
		}

		public boolean hasNext() {
			return c != 0;
		}

		public KEY_GENERIC_TYPE NEXT_KEY() {
			if ( ! hasNext() ) throw new NoSuchElementException();
			
			c--;
			// We are just enumerating elements from the wrapped list.
			if ( pos < 0 ) return wrapped.GET_KEY( - ( last = --pos ) - 2  );
			
			final KEY_GENERIC_TYPE retVal = key[ last = pos ];
			
			//System.err.println( "Count: " + c );
			if ( c != 0 ) {
				final boolean used[] = OPEN_HASH_SET.this.used;
				while ( pos-- != 0 && !used[ pos ] );
				// When here pos < 0 there are no more elements to be enumerated by scanning, but wrapped might be nonempty.
			}
			
			return retVal;
		}


		/** Shifts left entries with the specified hash code, starting at the specified position,
		 * and empties the resulting free entry. If any entry wraps around the table, instantiates
		 * lazily {@link #wrapped} and stores the entry.
		 *
		 * @param pos a starting position.
		 * @return the position cleared by the shifting process.
		 */
		final int shiftKeys( int pos ) {
			// Shift entries with the same hash.
			int last, slot;
	
			for(;;) {
				pos = ( ( last = pos ) + 1 ) & mask;
				
				while( used[ pos ] ) {
					slot = KEY2INTHASH( key[ pos ] ) & mask;
					if ( last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos ) break;
					pos = ( pos + 1 ) & mask;
				}
	
				if ( ! used[ pos ] ) break;
				if ( pos < last ) {
					// Wrapped entry.
					if ( wrapped == null ) wrapped = new ARRAY_LIST KEY_GENERIC();
					wrapped.add( key[ pos ] );
				}
				key[ last ] = key[ pos ];			
			}
	
			used[ last ] = false;
#if #keys(reference)
			key[ last ] = null;
#endif
			return last;
		}
	
		@SuppressWarnings("unchecked")
		public void remove() {
			if ( last == -1 ) throw new IllegalStateException();
			if ( pos < -1 ) {
				// We're removing wrapped entries.
#if #keys(reference)
				OPEN_HASH_SET.this.remove( wrapped.set( - pos - 2, null ) );
#else
				OPEN_HASH_SET.this.remove( wrapped.GET_KEY( - pos - 2 ) );
#endif
				last = -1;
				return;
			}
			size--;
			if ( shiftKeys( last ) == pos && c > 0 ) {
				c++;
				NEXT_KEY();
			}
			last = -1; // You can no longer remove this entry.
			if ( ASSERTS ) checkTable();
		}
	}

	public KEY_ITERATOR KEY_GENERIC iterator() {
		return new SetIterator();
	}

#endif



	/** A no-op for backward compatibility. The kind of tables implemented by
	 * this class never need rehashing.
	 *
	 * <P>If you need to reduce the table size to fit exactly
	 * this set, use {@link #trim()}.
	 *
	 * @return true.
	 * @see #trim()
	 * @deprecated A no-op.
	 */

	@Deprecated
	public boolean rehash() {
		return true;
	}


	/** Rehashes this set, making the table as small as possible.
	 * 
	 * <P>This method rehashes the table to the smallest size satisfying the
	 * load factor. It can be used when the set will not be changed anymore, so
	 * to optimize access speed and size.
	 *
	 * <P>If the table size is already the minimum possible, this method
	 * does nothing.
	 *
	 * @return true if there was enough memory to trim the set.
	 * @see #trim(int)
	 */

	public boolean trim() {
		final int l = arraySize( size, f );
		if ( l >= n ) return true;
		try {
			rehash( l );
		}
		catch(OutOfMemoryError cantDoIt) { return false; }
		return true;
	}


	/** Rehashes this set if the table is too large.
	 * 
	 * <P>Let <var>N</var> be the smallest table size that can hold
	 * <code>max(n,{@link #size()})</code> entries, still satisfying the load factor. If the current
	 * table size is smaller than or equal to <var>N</var>, this method does
	 * nothing. Otherwise, it rehashes this set in a table of size
	 * <var>N</var>.
	 *
	 * <P>This method is useful when reusing sets.  {@linkplain #clear() Clearing a
	 * set} leaves the table size untouched. If you are reusing a set
	 * many times, you can call this method with a typical
	 * size to avoid keeping around a very large table just
	 * because of a few large transient sets.
	 *
	 * @param n the threshold for the trimming.
	 * @return true if there was enough memory to trim the set.
	 * @see #trim()
	 */

	public boolean trim( final int n ) {
		final int l = HashCommon.nextPowerOfTwo( (int)Math.ceil( n / f ) );
		if ( this.n <= l ) return true;
		try {
			rehash( l );
		}
		catch( OutOfMemoryError cantDoIt ) { return false; }
		return true;
	}

	/** Resizes the set.
	 *
	 * <P>This method implements the basic rehashing strategy, and may be
	 * overriden by subclasses implementing different rehashing strategies (e.g.,
	 * disk-based rehashing). However, you should not override this method
	 * unless you understand the internal workings of this class.
	 *
	 * @param newN the new size
	 */

	@SuppressWarnings("unchecked")
	protected void rehash( final int newN ) {
#ifdef Linked
		int i = first, prev = -1, newPrev = -1, t, pos;
#else
		int i = 0, pos;
		final boolean used[] = this.used;
#endif

		KEY_GENERIC_TYPE k;
		final KEY_GENERIC_TYPE key[] = this.key;

		final int newMask = newN - 1;
		final KEY_GENERIC_TYPE newKey[] = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[ newN ];
		final boolean newUsed[] = new boolean[ newN ];
#ifdef Linked
		final long link[] = this.link;
		final long newLink[] = new long[ newN ];
		first = -1;
#endif

		for( int j = size; j-- != 0; ) {

#ifndef Linked
			while( ! used[ i ] ) i++;
#endif

			k = key[ i ];
			pos = KEY2INTHASH( k ) & newMask;

			while ( newUsed[ pos ] ) pos = ( pos + 1 ) & newMask;
				
			newUsed[ pos ] = true;
			newKey[ pos ] = k;

#ifdef Linked
			if ( prev != -1 ) {
				SET_NEXT( newLink[ newPrev ], pos );
				SET_PREV( newLink[ pos ], newPrev );
				newPrev = pos;
			}
			else {
				newPrev = first = pos;
				// Special case of SET(newLink[ pos ], -1, -1);
				newLink[ pos ] = -1L;
			}

			t = i;
			i = GET_NEXT(link[ i ]);
			prev = t;

#else
			i++;
#endif
		}

		n = newN;
		mask = newMask;
		maxFill = maxFill( n, f );
		this.key = newKey;
		this.used = newUsed;
#ifdef Linked
		this.link = newLink;
		this.last = newPrev;
		if ( newPrev != -1 )
			// Special case of SET_NEXT( newLink[ newPrev ], -1 );
			newLink[ newPrev ] |= -1 & 0xFFFFFFFFL;
#endif
	}


	/** Returns a deep copy of this set. 
	 *
	 * <P>This method performs a deep copy of this hash set; the data stored in the
	 * set, however, is not cloned. Note that this makes a difference only for object keys.
	 *
	 *  @return a deep copy of this set.
	 */

	@SuppressWarnings("unchecked")
	public OPEN_HASH_SET KEY_GENERIC clone() {
		OPEN_HASH_SET KEY_GENERIC c;
		try {
			c = (OPEN_HASH_SET KEY_GENERIC)super.clone();
		}
		catch(CloneNotSupportedException cantHappen) {
			throw new InternalError();
		}
		c.key = key.clone();
		c.used = used.clone();
#ifdef Linked
		c.link = link.clone();
#endif
#ifdef Custom
		c.strategy = strategy;
#endif
		return c;
	}

	/** Returns a hash code for this set.
	 *
	 * This method overrides the generic method provided by the superclass. 
	 * Since <code>equals()</code> is not overriden, it is important
	 * that the value returned by this method is the same value as
	 * the one returned by the overriden method.
	 *
	 * @return a hash code for this set.
	 */


	public int hashCode() {
		int h = 0, i = 0, j = size;
		while( j-- != 0 ) {
			while( ! used[ i ] ) i++;
#if #keys(reference)
			if ( this != key[ i ] )
#endif
				h += KEY2JAVAHASH( key[ i ] );
			i++;
		}
		return h;
	}


	private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
		final KEY_ITERATOR KEY_GENERIC i = iterator();
		s.defaultWriteObject();
		for( int j = size; j-- != 0; ) s.WRITE_KEY( i.NEXT_KEY() );
	}


	@SuppressWarnings("unchecked")
	private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
		s.defaultReadObject();

		n = arraySize( size, f );
		maxFill = maxFill( n, f );
		mask = n - 1;
		
		final KEY_GENERIC_TYPE key[] = this.key = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[ n ];
		final boolean used[] = this.used = new boolean[ n ];
#ifdef Linked
		final long link[] = this.link = new long[ n ];
		int prev = -1;
		first = last = -1;
#endif

		KEY_GENERIC_TYPE k;

		for( int i = size, pos = 0; i-- != 0; ) {

			k = KEY_GENERIC_CAST s.READ_KEY();
			pos = KEY2INTHASH( k ) & mask;

			while ( used[ pos ] ) pos = ( pos + 1 ) & mask;

			used[ pos ] = true;
			key[ pos ] = k;

#ifdef Linked
			if ( first != -1 ) {
				SET_NEXT( link[ prev ], pos );
				SET_PREV( link[ pos ], prev );
				prev = pos;
			}
			else {
				prev = first = pos;
				// Special case of SET_PREV( newLink[ pos ], -1 );
				link[ pos ] |= (-1L & 0xFFFFFFFFL) << 32;
			}
#endif
		}

#ifdef Linked
		last = prev;
		if ( prev != -1 ) 
			// Special case of SET_NEXT( link[ prev ], -1 );
			link[ prev ] |= -1 & 0xFFFFFFFFL; 
#endif

		if ( ASSERTS ) checkTable();
	}


#ifdef ASSERTS_CODE
	private void checkTable() {
		final boolean[] used = this.used;
		assert ( n & -n ) == n : "Table length is not a power of two: " + n;
		assert n == key.length;
		assert n == used.length;
		int n = used.length;
		while( n-- != 0 ) 
			if ( used[ n ] && ! contains( key[ n ] ) ) 
				throw new AssertionError( "Hash table has key " + key[ n ] + " marked as occupied, but the key does not belong to the table" );

#if #keys(primitive)
		java.util.HashSet<KEY_GENERIC_CLASS> s = new java.util.HashSet<KEY_GENERIC_CLASS> ();
#else
		java.util.HashSet<Object> s = new java.util.HashSet<Object>();
#endif
		
		for( int i = used.length; i-- != 0; )
			if ( used[ i ] && ! s.add( key[ i ] ) ) throw new AssertionError( "Key " + key[ i ] + " appears twice at position " + i );

#ifdef Linked
		KEY_LIST_ITERATOR KEY_GENERIC i = iterator();
		KEY_GENERIC_TYPE k;
		n = size();
		while( n-- != 0 ) 
			if ( ! contains( k = i.NEXT_KEY() ) ) 
				throw new AssertionError( "Linked hash table forward enumerates key " + k + ", but the key does not belong to the table" );

		if ( i.hasNext() ) throw new AssertionError( "Forward iterator not exhausted" );

		n = size();
		if ( n > 0 ) {
			i = iterator( LAST() );
			while( n-- != 0 ) 
				if ( ! contains( k = i.PREV_KEY() ) ) 
					throw new AssertionError( "Linked hash table backward enumerates key " + k + ", but the key does not belong to the table" );
			
			if ( i.hasPrevious() ) throw new AssertionError( "Previous iterator not exhausted" );
		}
#endif
	}
#else
	private void checkTable() {}
#endif

#ifdef TEST

	private static long seed = System.currentTimeMillis(); 
	private static java.util.Random r = new java.util.Random( seed );

	private static KEY_TYPE genKey() {
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
		return (KEY_TYPE)(r.nextInt());
#elif #keys(primitive)
		return r.NEXT_KEY(); 
#elif #keyclass(Object)
#ifdef Custom
		int i = r.nextInt( 3 );
		byte a[] = new byte[ i ];
		while( i-- != 0 ) a[ i ] = (byte)r.nextInt();
		return a;
#else
		return Integer.toBinaryString( r.nextInt() );
#endif
#else
		return new java.io.Serializable() {};
#endif
	}


	private static final class ArrayComparator implements java.util.Comparator {
		public int compare( Object a, Object b ) {
			byte[] aa = (byte[])a;
			byte[] bb = (byte[])b;
			int length = Math.min( aa.length, bb.length );
			for( int i = 0; i < length; i++ ) {
				if ( aa[ i ] < bb[ i ] ) return -1;
				if ( aa[ i ] > bb[ i ] ) return 1;
			}
			return aa.length == bb.length ? 0 : ( aa.length < bb.length ? -1 : 1 );
		}
	}

	private static final class MockSet extends java.util.TreeSet {
		private java.util.List list = new java.util.ArrayList();

		public MockSet( java.util.Comparator c ) { super( c ); }

		public boolean add( Object k ) {
			if ( ! contains( k ) ) list.add( k );
			return super.add( k );
		}

		public boolean addAll( Collection c ) {
			java.util.Iterator i = c.iterator();
			boolean result = false;
			while( i.hasNext() ) result |= add( i.next() );
			return result;
		}

		public boolean removeAll( Collection c ) {
			java.util.Iterator i = c.iterator();
			boolean result = false;
			while( i.hasNext() ) result |= remove( i.next() );
			return result;
		}

		public boolean remove( Object k ) {
			if ( contains( k ) ) {
				int i = list.size();
				while( i-- != 0 ) if ( comparator().compare( list.get( i ), k ) == 0 ) {
					list.remove( i );
					break;
				}
			}
			return super.remove( k );
		}

		private void justRemove( Object k ) { super.remove( k ); }

		public java.util.Iterator iterator() {
			return new java.util.Iterator() {
					final java.util.Iterator iterator = list.iterator();
					Object curr;
					public Object next() { return curr = iterator.next(); }
					public boolean hasNext() { return iterator.hasNext(); }
					public void remove() { 
						justRemove( curr );
						iterator.remove(); 
					}
				};
		}
	}

	private static java.text.NumberFormat format = new java.text.DecimalFormat( "#,###.00" );
	private static java.text.FieldPosition fp = new java.text.FieldPosition( 0 );

	private static String format( double d ) {
		StringBuffer s = new StringBuffer();
		return format.format( d, s, fp ).toString();
	}

	private static void speedTest( int n, float f, boolean comp ) {
#ifndef Custom
		int i, j;
		OPEN_HASH_SET m;
#ifdef Linked
		java.util.LinkedHashSet t;
#else
		java.util.HashSet t;
#endif

		KEY_TYPE k[] = new KEY_TYPE[n];
		KEY_TYPE nk[] = new KEY_TYPE[n];
		long ms;

		for( i = 0; i < n; i++ ) {
			k[i] = genKey();
			nk[i] = genKey();
		}
		  
		double totAdd = 0, totYes = 0, totNo = 0, totIter = 0, totRemYes = 0, totRemNo = 0, d;

		if ( comp ) { for( j = 0; j < 20; j++ ) {

#ifdef Linked
			t = new java.util.LinkedHashSet( 16 );
#else
			t = new java.util.HashSet( 16 );
#endif

			/* We add pairs to t. */
			ms = System.currentTimeMillis();
			for( i = 0; i < n;  i++ ) t.add( KEY2OBJ( k[i] ) );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totAdd += d; 				
			System.out.print("Add: " + format( d ) +" K/s " );

			/* We check for pairs in t. */
			ms = System.currentTimeMillis();
			for( i = 0; i < n;  i++ ) t.contains( KEY2OBJ( k[i] ) );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totYes += d; 				
			System.out.print("Yes: " + format( d ) +" K/s " );

			/* We check for pairs not in t. */
			ms = System.currentTimeMillis();
			for( i = 0; i < n;  i++ ) t.contains( KEY2OBJ( nk[i] ) );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totNo += d; 				
			System.out.print("No: " + format( d ) +" K/s " );

			/* We iterate on t. */
			ms = System.currentTimeMillis();
			for( java.util.Iterator it = t.iterator(); it.hasNext(); it.next() );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totIter += d; 				
			System.out.print("Iter: " + format( d ) +" K/s " );
				
			// Too expensive in the linked case			
#ifndef Linked
			/* We delete pairs not in t. */
			ms = System.currentTimeMillis();
			for( i = 0; i < n;  i++ ) t.remove( KEY2OBJ( nk[i] ) );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totRemNo += d; 				
			System.out.print("RemNo: " + format( d ) +" K/s " );
	
			/* We delete pairs in t. */
			ms = System.currentTimeMillis();
			for( i = 0; i < n;  i++ ) t.remove( KEY2OBJ( k[i] ) );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totRemYes += d; 				
			System.out.print("RemYes: " + format( d ) +" K/s " );
#endif
				
			System.out.println();
		}

		System.out.println();
		System.out.println( "java.util Add: " + format( totAdd/(j-3) ) + " K/s Yes: " + format( totYes/(j-3) ) + " K/s No: " + format( totNo/(j-3) ) + " K/s Iter: " + format( totIter/(j-3) ) + " K/s RemNo: " + format( totRemNo/(j-3) ) + " K/s RemYes: " + format( totRemYes/(j-3) ) + "K/s" );

		System.out.println();

		totAdd = totYes = totNo = totIter = totRemYes = totRemNo = 0;
		}

		for( j = 0; j < 20; j++ ) {

			m = new OPEN_HASH_SET( 16, f );

			/* We add pairs to m. */
			ms = System.currentTimeMillis();
			for( i = 0; i < n;  i++ ) m.add( k[i] );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totAdd += d; 				
			System.out.print("Add: " + format( d ) +" K/s " );

			/* We check for pairs in m. */
			ms = System.currentTimeMillis();
			for( i = 0; i < n;  i++ ) m.contains( k[i] );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totYes += d; 				
			System.out.print("Yes: " + format( d ) +" K/s " );

			/* We check for pairs not in m. */
			ms = System.currentTimeMillis();
			for( i = 0; i < n;  i++ ) m.contains( nk[i] );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totNo += d; 				
			System.out.print("No: " + format( d ) +" K/s " );

			/* We iterate on m. */
			ms = System.currentTimeMillis();
			for( KEY_ITERATOR it = (KEY_ITERATOR)m.iterator(); it.hasNext(); it.NEXT_KEY() );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totIter += d; 	 
			System.out.print("Iter: " + format( d ) +" K/s " );

			// Too expensive in the linked case			
#ifndef Linked
			/* We delete pairs not in m. */
			ms = System.currentTimeMillis();
			for( i = 0; i < n;  i++ ) m.remove( nk[i] );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totRemNo += d; 	
			System.out.print("RemNo: " + format( d ) +" K/s " );

			/* We delete pairs in m. */
			ms = System.currentTimeMillis();
			for( i = 0; i < n;  i++ ) m.remove( k[i] );
			d = 1.0 * n / (System.currentTimeMillis() - ms );
			if ( j > 2 ) totRemYes += d; 				
			System.out.print("RemYes: " + format( d ) +" K/s " );	 
#endif

			System.out.println();
		}


		System.out.println();
		System.out.println( "fastutil  Add: " + format( totAdd/(j-3) ) + " K/s Yes: " + format( totYes/(j-3) ) + " K/s No: " + format( totNo/(j-3) ) + " K/s Iter: " + format( totIter/(j-3) ) + " K/s RemNo: " + format( totRemNo/(j-3) ) + " K/s RemYes: " + format( totRemYes/(j-3) ) + " K/s" );

		System.out.println();
#endif
	}


	private static void fatal( String msg ) {
		System.out.println( msg );
		System.exit( 1 );
	}

	private static void ensure( boolean cond, String msg ) {
		if ( cond ) return;
		fatal( msg );
	}


	private static void printProbes( OPEN_HASH_SET m ) {
		long totProbes = 0;
		double totSquareProbes = 0;
		int maxProbes = 0;	
		final double f = (double)m.size / m.n;
		for( int i = 0, c = 0; i < m.n; i++ ) {
			if ( m.used[ i ] ) c++;
			else {
				if ( c != 0 ) {
					final long p = ( c + 1 ) * ( c + 2 ) / 2;
					totProbes += p;
					totSquareProbes += (double)p * p;
				}
				maxProbes = Math.max( c, maxProbes );
				c = 0;
				totProbes++;
				totSquareProbes++;
			}
		}

		final double expected = (double)totProbes / m.n;
		System.err.println( "Expected probes: " + ( 
			3 * Math.sqrt( 3 ) * ( f / ( ( 1 - f ) * ( 1 - f ) ) ) + 4 / ( 9 * f ) - 1
		) + "; actual: " + expected + "; stddev: " + Math.sqrt( totSquareProbes / m.n - expected * expected )  + "; max probes: " + maxProbes );
	}
	
	
	private static void test( int n, float f ) {
#if !defined(Custom) || #keys(reference)

		int c;
#ifdef Custom
		OPEN_HASH_SET m = new OPEN_HASH_SET(Hash.DEFAULT_INITIAL_SIZE, f, it.unimi.dsi.fastutil.bytes.ByteArrays.HASH_STRATEGY);
#else
		OPEN_HASH_SET m = new OPEN_HASH_SET(Hash.DEFAULT_INITIAL_SIZE, f);
#endif
#ifdef Linked
#ifdef Custom
		java.util.Set t = new MockSet(new ArrayComparator());
#else
		java.util.Set t = new java.util.LinkedHashSet();
#endif
#else
#ifdef Custom
		java.util.Set t = new java.util.TreeSet(new ArrayComparator());
#else 
		java.util.Set t = new java.util.HashSet();
#endif
#endif

		/* First of all, we fill t with random data. */

		for(int i=0; i<f * n;  i++ ) t.add(KEY2OBJ(genKey()));
		  
		/* Now we add to m the same data */
		  
		m.addAll(t); 

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after insertion");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after insertion");
		printProbes( m );

		/* Now we check that m actually holds that data. */
		  
		for(java.util.Iterator i=t.iterator(); i.hasNext();  ) {
			Object e = i.next();
			if (!m.contains(e)) {
				System.out.println("Error (" + seed + "): m and t differ on a key ("+e+") after insertion (iterating on t)");
				System.exit( 1 );
			}
		}

		/* Now we check that m actually holds that data, but iterating on m. */

		c = 0;		  
		for(java.util.Iterator i=m.iterator(); i.hasNext();  ) {
			Object e = i.next();
			c++;
			if (!t.contains(e)) {
				System.out.println("Error (" + seed + "): m and t differ on a key ("+e+") after insertion (iterating on m)");
				System.exit( 1 );
			}
		}

		if ( c != t.size() ) {
			System.out.println("Error (" + seed + "): m has only " + c + " keys instead of " + t.size() + " after insertion (iterating on m)");
			System.exit( 1 );
		}
		/* Now we check that inquiries about random data give the same answer in m and t. For
		   m we use the polymorphic method. */

		for(int i=0; i<n;  i++ ) {
			KEY_TYPE T = genKey();
			if (m.contains(T) != t.contains(KEY2OBJ(T))) {
				System.out.println("Error (" + seed + "): divergence in keys between t and m (polymorphic method)");
				System.exit( 1 );
			}
		}

		/* Again, we check that inquiries about random data give the same answer in m and t, but
		   for m we use the standard method. */

		for(int i=0; i<n;  i++ ) {
			KEY_TYPE T = genKey();
			if (m.contains(KEY2OBJ(T)) != t.contains(KEY2OBJ(T))) {
				System.out.println("Error (" + seed + "): divergence between t and m (standard method)");
				System.exit( 1 );
			}
		}


		/* Now we put and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++ ) {
			KEY_TYPE T = genKey();
			if (m.add(KEY2OBJ(T)) != t.add(KEY2OBJ(T))) {
				System.out.println("Error (" + seed + "): divergence in add() between t and m");
				System.exit( 1 );
			}
			T = genKey();
			if (m.remove(KEY2OBJ(T)) != t.remove(KEY2OBJ(T))) {
				System.out.println("Error (" + seed + "): divergence in remove() between t and m");
				System.exit( 1 );
			}
		}

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after removal");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after removal");

		/* Now we check that m actually holds that data. */
		  
		for(java.util.Iterator i=t.iterator(); i.hasNext();  ) {
			Object e = i.next();
			if (!m.contains(e)) {
				System.out.println("Error (" + seed + "): m and t differ on a key ("+e+") after removal (iterating on t)");
				System.exit( 1 );
			}
		}

		/* Now we check that m actually holds that data, but iterating on m. */
		  
		for(java.util.Iterator i=m.iterator(); i.hasNext();  ) {
			Object e = i.next();
			if (!t.contains(e)) {
				System.out.println("Error (" + seed + "): m and t differ on a key ("+e+") after removal (iterating on m)");
				System.exit( 1 );
			}
		}

		printProbes( m );

		/* Now we make m into an array, make it again a set and check it is OK. */
		KEY_TYPE a[] = m.TO_KEY_ARRAY();
		  
#ifdef Custom
		if (!new OPEN_HASH_SET(a, m.strategy()).equals(m))
			System.out.println("Error (" + seed + "): toArray() output (or array-based constructor) is not OK");
#else
		if (!new OPEN_HASH_SET(a).equals(m))
			System.out.println("Error (" + seed + "): toArray() output (or array-based constructor) is not OK");
#endif

		/* Now we check cloning. */

		ensure( m.equals( ((OPEN_HASH_SET)m).clone() ), "Error (" + seed + "): m does not equal m.clone()" );
		ensure( ((OPEN_HASH_SET)m).clone().equals( m ), "Error (" + seed + "): m.clone() does not equal m" );

		int h = m.hashCode();

		/* Now we save and read m. */

		try {
			java.io.File ff = new java.io.File("it.unimi.dsi.fastutil.test");
			java.io.OutputStream os = new java.io.FileOutputStream(ff);
			java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);
				
			oos.writeObject(m);
			oos.close();
				
			java.io.InputStream is = new java.io.FileInputStream(ff);
			java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);
				
			m = (OPEN_HASH_SET)ois.readObject();
			ois.close();
			ff.delete();
		}
		catch(Exception e) {
			e.printStackTrace();
			System.exit( 1 );
		}

#if !#keyclass(Reference)
		if (m.hashCode() != h) System.out.println("Error (" + seed + "): hashCode() changed after save/read");

		printProbes( m );

		/* Now we check that m actually holds that data, but iterating on m. */
		  
		for(java.util.Iterator i=m.iterator(); i.hasNext();  ) {
			Object e = i.next();
			if (!t.contains(e)) {
				System.out.println("Error (" + seed + "): m and t differ on a key ("+e+") after save/read");
				System.exit( 1 );
			}
		}
#else
		m.clear();
		m.addAll( t );
#endif

		/* Now we put and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++ ) {
			KEY_TYPE T = genKey();
			if (m.add(KEY2OBJ(T)) != t.add(KEY2OBJ(T))) {
				System.out.println("Error (" + seed + "): divergence in add() between t and m after save/read");
				System.exit( 1 );
			}
			T = genKey();
			if (m.remove(KEY2OBJ(T)) != t.remove(KEY2OBJ(T))) {
				System.out.println("Error (" + seed + "): divergence in remove() between t and m after save/read");
				System.exit( 1 );
			}
		}

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after post-save/read removal");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after post-save/read removal");


#ifdef Linked

				 
		/* Now we play with iterators, but only in the linked case. */

		{
			java.util.ListIterator i, j;
			Object I, J;
			i = (java.util.ListIterator)m.iterator(); 
			j = new java.util.LinkedList( t ).listIterator(); 

			for( int k = 0; k < 2*n; k++ ) {
				ensure( i.hasNext() == j.hasNext(), "Error (" + seed + "): divergence in hasNext()" );
				ensure( i.hasPrevious() == j.hasPrevious(), "Error (" + seed + "): divergence in hasPrevious()" );

				if ( r.nextFloat() < .8 && i.hasNext() ) {
#ifdef Custom
					ensure( m.strategy().equals( i.next(), J = j.next() ), "Error (" + seed + "): divergence in next()" );
#else
					ensure( i.next().equals( J = j.next() ), "Error (" + seed + "): divergence in next()" );
#endif
					if ( r.nextFloat() < 0.5 ) {
						i.remove();
						j.remove();
						t.remove( J );
					}
				}
				else if ( r.nextFloat() < .2 && i.hasPrevious() ) {
#ifdef Custom
					ensure( m.strategy().equals( i.previous(), J = j.previous() ), "Error (" + seed + "): divergence in previous()" );
#else
					ensure( i.previous().equals( J = j.previous() ), "Error (" + seed + "): divergence in previous()" );
#endif
					if ( r.nextFloat() < 0.5 ) {
						i.remove();
						j.remove();
						t.remove( J );
					}
				}

				ensure( i.nextIndex() == j.nextIndex(), "Error (" + seed + "): divergence in nextIndex()" );
				ensure( i.previousIndex() == j.previousIndex(), "Error (" + seed + "): divergence in previousIndex()" );

			}

		}

		if ( t.size() > 0 ) {
			java.util.ListIterator i, j;
			Object J;
			j = new java.util.LinkedList( t ).listIterator(); 
			int e = r.nextInt( t.size() );
			Object from;
			do from = j.next(); while( e-- != 0 );

			i = (java.util.ListIterator)m.iterator( KEY_OBJ2TYPE( from ) ); 

			for( int k = 0; k < 2*n; k++ ) {
				ensure( i.hasNext() == j.hasNext(), "Error (" + seed + "): divergence in hasNext() (iterator with starting point " + from + ")" );
				ensure( i.hasPrevious() == j.hasPrevious(), "Error (" + seed + "): divergence in hasPrevious() (iterator with starting point " + from + ")" );

				if ( r.nextFloat() < .8 && i.hasNext() ) {
#ifdef Custom
					ensure( m.strategy().equals( i.next(), J = j.next() ), "Error (" + seed + "): divergence in next() (iterator with starting point " + from + ")" );
#else
					ensure( i.next().equals( J = j.next() ), "Error (" + seed + "): divergence in next() (iterator with starting point " + from + ")" );
#endif

					if ( r.nextFloat() < 0.5 ) {
						i.remove();
						j.remove();
						t.remove( J );
					}
				}
				else if ( r.nextFloat() < .2 && i.hasPrevious() ) {
#ifdef Custom
					ensure( m.strategy().equals( i.previous(), J = j.previous() ), "Error (" + seed + "): divergence in previous() (iterator with starting point " + from + ")" );
#else
					ensure( i.previous().equals( J = j.previous() ), "Error (" + seed + "): divergence in previous() (iterator with starting point " + from + ")" );
#endif

					if ( r.nextFloat() < 0.5 ) {
						i.remove();
						j.remove();
						t.remove( J );
					}
				}

				ensure( i.nextIndex() == j.nextIndex(), "Error (" + seed + "): divergence in nextIndex() (iterator with starting point " + from + ")" );
				ensure( i.previousIndex() == j.previousIndex(), "Error (" + seed + "): divergence in previousIndex() (iterator with starting point " + from + ")" );

			}

		}

		/* Now we check that m actually holds that data. */
		  
		ensure( m.equals(t), "Error (" + seed + "): ! m.equals( t ) after iteration" );
		ensure( t.equals(m), "Error (" + seed + "): ! t.equals( m ) after iteration" );



#endif

		/* Now we take out of m everything, and check that it is empty. */

		for(java.util.Iterator i=m.iterator(); i.hasNext(); ) { i.next(); i.remove();} 

		if (!m.isEmpty())  {
			System.out.println("Error (" + seed + "): m is not empty (as it should be)");
			System.exit( 1 );
		}

#if #keyclass(Integer) || #keyclass(Long)
		m = new OPEN_HASH_SET(n, f);
		t.clear();
		int x;

		/* Now we torture-test the hash table. This part is implemented only for integers and longs. */

		int p = m.used.length;

		for(int i=0; i<p; i++) {
			for (int j=0; j<20; j++) {
				m.add(i+(r.nextInt() % 10)*p);
				m.remove(i+(r.nextInt() % 10)*p);
			}

			for (int j=-10; j<10; j++) m.remove(i+j*p);
		}
		  
		t.addAll(m);

		/* Now all table entries are REMOVED. */
 
		int k = 0;
		for(int i=0; i<(p*f)/10; i++) {
			for (int j=0; j<10; j++) {
				k++;
				x = i+(r.nextInt() % 10)*p;
				if (m.add(x) != t.add(KEY2OBJ(x)))
					System.out.println("Error (" + seed + "): m and t differ on a key during torture-test insertion.");
			}
		}

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after torture-test insertion");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after torture-test insertion");

		for(int i=0; i<(p*f)/10; i++) {
			for (int j=0; j<10; j++) {
				x = i+(r.nextInt() % 10)*p;
				if (m.remove(x) != t.remove(KEY2OBJ(x)))
					System.out.println("Error (" + seed + "): m and t differ on a key during torture-test removal.");
			}
		}

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after torture-test removal");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after torture-test removal");

		if (!m.equals(m.clone())) System.out.println("Error (" + seed + "): !m.equals(m.clone()) after torture-test removal");
		if (!((OPEN_HASH_SET)m.clone()).equals(m)) System.out.println("Error (" + seed + "): !m.clone().equals(m) after torture-test removal");

		m.rehash();

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after rehash()");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after rehash()");

		m.trim();

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after trim()");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after trim()");
#endif

		System.out.println("Test OK");
		return;
#endif
	}


	public static void main( String args[] ) {
		float f = Hash.DEFAULT_LOAD_FACTOR;
		int n  = Integer.parseInt(args[1]);
		if (args.length>2) f = Float.parseFloat(args[2]);
		if ( args.length > 3 ) r = new java.util.Random( seed = Long.parseLong( args[ 3 ] ) );
		  
		try {
			if ("speedTest".equals(args[0]) || "speedComp".equals(args[0])) speedTest( n, f, "speedComp".equals(args[0]) );
			else if ( "test".equals( args[0] ) ) test(n, f);
		} catch( Throwable e ) {
			e.printStackTrace( System.err );
			System.err.println( "seed: " + seed );
		}
	}

#endif

}
